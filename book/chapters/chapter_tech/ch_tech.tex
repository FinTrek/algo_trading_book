% !TEX root = ../../book.tex
%\hfill
%\par\vspace{\baselineskip}

\chapter{The Technology Stack}
There are a broad spectrum of trading infrastructures and operations but none, we think, is as broad and complex as the one in a large electronic trading execution operation in a large Broker-Dealer. So we use that as a template for our exploration of the technology stack that is necessary to support such an operation. We start by reviewing the end to end flow of information and then go into some detail on the various components. As previously discussed all large ET businesses also operate their own ATS so we'll briefly look at the technology setup needed to support that use case as well.
\section{From client Instruction to Trade Reconciliation}
TODO Build an end-to-end diagram

Figure~\ref{fig:pexchrate} shows the end to end diagram of a hypothetical trading infrastructure. We can use this diagram to follow the full lifecycle of a client order and the main components of the infrastructure involved.
\subsection{Client Side}
The trader enters an algorithmic order into her Execution Management System (EMS) a specialized trading infrastructure that integrates with internal systems and provides all the tools an institutional traders needed to manage her day to day trading needs. EMS are most often vendor products with Ez Castle \footnote{\url{https://www.ezesoft.com/}}, Portware \footnote{\url{http://www.portware.com/}}and FlexTrade \footnote{\url{https://flextrade.com/}} some of the most popular options. Many larger buy-side trade organizations have more complex needs and often have an homegrown solution.\\

The trader chooses from a drop-down menu the particular provider and Algo strategy and  chooses the desired parameters. Every broker that wants to expose their execution into an EMS needs to certify with the EMS by providing a FIX Specification Document that highlights what strategy are available and what parameters are available for each and the validation information about the parameter. The EMS integrates this into their system and exposes them in the front end for the trader to chose. FIX stands for \emph{Financial Information eXchange} and it's a standard communication protocol specifically designed for financial applications \footnote{\url{https://www.fixtrading.org/}}\\

Once the order is submitted the EMS uses a preconfigured network connection to transfer the order to the broker. This session is created as part of the \emph{Client Onboarding} step a quite laborious process to setup a new client relationship, configure the client financial limits and controls.

\subsection{Inbound Gateway}
We are now broker-side where the order is received by and Inbound gateway. The first think to happen is some form of validation to ensure that the message is a valid order and has all the necessary fields. Next step is to perform a set of risk and credit checks to ensure that the order is within the specified risk limits and the client overall exposure, the maximum notional the client is allowed to trade and have in the market at any point in time. Any mismatch in these validation steps and the order is rejected back to the client.

\subsection{Order Management System and Order Enrichment}
Once the order is validated it is created within the broker dealer infrastructure. Order life-cycle is quite complicated and nuanced and it is critical that the state of the order is always up to date and state transitions carefully managed. The role of creating and managing the state of the order is fulfilled by an Order Management System (OMS). These infrastructures are at the heart of any trading operation and are one of the most important components. They are often built around a Bus based architecture a software paradigm where loosely couple components communicated with each other over a messaging middleware. The advantage of this approach is that other ancillary components within the infrastructure can ``Listen in'' on the messages and use the information to affect other systems or collect the data for trade reporting, and analysis.\\

One step often performed in this layer is Order Enrichment. This is a step that adds additional, lower level parameters that adjust and customize the execution behavior for the specific client/algorithm/parameters triplet. This step also translates nuances between the instruction the client sends and what the execution system understands. This is often accomplished by a specialized \emph{Rules Engine} a software library that allows a set of rules to be applied to an order and then re-evaluate the rules after any modification until no rules are triggered.

\subsection{Execution Strategy Stack}
And this is, as the famous expression quote: ``Is where the magic happens!'' The order reaches the software component where the Algo is actually executed. We'll delve into more details in on the execution stack in the next section so here we just assume that the strategy is initialized and starts executing. The strategy is associated with the order contained in the OMS often called the ``Parent Order'' and as consequence of the strategy logic one or more ``child'' orders  are created in the OMS and the sent forward for submission to one or more trading venue. Before the order are actually forwarded the order passes through an additional control layer to ensure the strategy does not violate the risk limits and speed bumps, general term used for limits that prevents the strategy from trading too fast or too aggressively or send too many child orders, etc.

\subsection{Outbound Gateway}
The child orders are received by another piece of infrastructure that is responsible for actually sending the orders to the market: The Outbound Gateway. All venues support one more protocols to communicate with market participants. Essentially all of them support a FIX protocol but in most cases they also support a much faster ``native'' protocol that encodes the instructions in a compressed binary protocol. The role of the Outbound Gateway is to connect to the various venues and then act as a translation layer from the internal representation in the OMS to the external representation of the specific protocol implemented by the venue. The outbound gateway also listens to the connection callback to capture any asynchronous event coming from the venue like order insert/cancellation acknowledgements and executions events, and updates the state of the child order representation in the OMS.

\subsection{Notifications to the Client}
As the strategy executes orders in the market the OMS keeps the state of the parent order up-to-date and either every execution or periodically send updates back via the inbound gateway back to the client's EMS that update its own state and provide feedback to the trader that the strategy is executing,  what the average prices achieved, and other analytics necessary for the trader to understand how well the strategy is executing. The inbound control layer is also kept uptodate so that the total state of all client orders is accounted for if/when a new order from the same client is received.\\

\subsection{Back Office}
We are almost done. The step above completes the real-time feedback loop from the client through the executing strategy to the market and back. The rest of the processing is in most cases done offline by a set of infrastructures commonly referred as ``Back Office Systems.'' These systems play a critical role in the business and regulatory side of trading:

TODO Get clear picture of these steps.

\section{Algorithmic Trading Infrastructure}
This section details a somewhat generic approach for algorithmic trading infrastructure. Different providers have different approaches to this. For instance some platform the core strategy is in one infrastructure but the order routing part is a separate (albeit similar) infrastructure. Other combine the two parts together, other still separate scheduling and order placement/routing components. The below simplified setup assumes an all-in-one approach.\\

The core of an Algorithmic Trader infrastructure is a software framework generically called ``Strategy Container.'' This facility sits in-between the low level OMS related functionality and the strategy and provides a set of abstractions and interfaces to simplify the development of a trading algorithm.  When a new order event is received from the OMS the strategy container reads and validates the instructions like the name of the strategy and the necessary and additional parameters. If this is a valid new order instruction it usually has to pass through and additional layer of controls to ensure that various variables such as order quantity or limit price are within the required boundaries. Once this validation step is completed the strategy container instantiates the code that encodes the particular strategy, initializes it with the specific parameters. It will also connect the algorithm to the necessary services the algorithms needs to implement the strategy.\\  Let's look at some of the main services and related infrastructures:
\subsection{Static Data Services}
An Algorithmic strategy requires a slew of reference data and other static data to operate. First and foremost the particular instrument the strategy is trading but also other information like primary exchange, exchange open/close time, etc. It will also require the normalizing analytics as well as any calibration parameters for the various models. These static data services abstract the sources of the underlying data that could be databases, flat files and calls to other systems.
\subsection{Market Data Facility}
Access to real-time market data is the most important component of any trading algorithm. Strategy container is usually provided with two way of accessing this data: via a data cache that is continuously kept uptodate by some underlying thread, and via callback. The data cache also continuously updates additional core analytics used by the strategy such as total traded volume (filtered for specific condition codes) and others. Natural question is, how do we actually get real-time market data? Connected to our market data facility is one of the most demanding and expensive pieces of infrastructure in our whole stack: the Market Data Plant. This is worth a small detour.
\subsubsection{Market Data Plant} 
Any serious trading operation, in particular in the post NMS era and the Order Protection Rule requires to access protected quotes, needs to subscribe and deliver direct market feeds from all protected exchanges. For most usecases top of book (Level I) data is not going to be sufficient and you need to subscribe to at least Level 2 or even better Level 3 data. Each exchange family (and sometime even within one) has it's own proprietary multicast protocol. Also very important information like trade condition codes are also proprietary and need to be normalized. For each level 3 market data feed on needs a book building library that interprets all the multicast event and updates the internal state of the book. Doing this in a very efficient way that can withstand market data spikes without dropping any multicast packet is not an easy task and requires skills and excellent networking and compute infrastructure something that is not cheap to build and maintain. More an more often trading operation rely on third party vendor that often provide a hybrid software and hardware solution to handle the whole operation. Some of the most important vendors in this space are: Reuters \footnote{\url{https://financial.thomsonreuters.com/en.html}}, Redline  Trading Solutions \footnote{\url{https://www.redlinetrading.com/}}, Exegy \footnote{\url{https://www.exegy.com/}}.
On top of the significant costs of operations  exchanges have ratcheted up the cost of market data subscription to a level some people could call extortionary making market data a significant component of the overall cost of running a trading operation (in the the six digit range!).
\subsubsection{Outbound Order Interface}
Back to our core services. The last core set of abstractions has to do with managing outbound child orders. This facility provides the strategy with the state of all outstanding child orders and ability to create, cancel and amend them in an asynchronous way and managing any exceptions like for example trying to cancel an order that has just executed on exchange but the fill event has not yet reached the OMS. 

\subsection{Main Strategy Loop}
We come to the \emph{core of the Core} of the whole infrastructure. While there is many ways to write a trading strategy a pattern has emerged that has become somewhat of a standard approach. It's sometimes referred as the Main Strategy Loop. \footnote{Some practitioners for example believe that the right conceptual framework for a strategy is that of a State Machine: Based on what event just happen there is a ``state transition'' in the next state and writing a strategy is essentially to model and implement these state transitions. Conceptually elegant, in practice this approach is extremely hard to pull off as there are a lot of side effects and co-dependencies that makes it hard to cleanly decompose}
The strategy container other working threads ensure the state is always kept up to date. The strategy flow is encoded in essentially one stateless function that is called on either a timer, any major event such as quote change/trade/execution, etc., or just a tight loop. This function perform three phases:
\begin{enumerate}
\item Understand where the strategy is at any point in time by recovering the state from the state cache with all the information it needs. How many shares I have done and how many, based on my target strategy should I be at this point and where should I try to be in the near future. 
\item Based on the full information set and the current state of the outstanding child orders in the market determine what orders to cancel and what orders to submit.
\item Send these instructions to the Outbound Order Interface. In some cases step \#2 just calculate the correct exposure it wants in the market and it's the role of this step to optimally decide if and how this should be implemented by either submitting additional orders or amending the existing ones, etc.
\end{enumerate}
After performing these three steps the main loop exists and the loop repeats some time later. Since the approach in mathematical terms Markovian, meaning that ti only depends on the existing state, if the strategy is called again immediately after it will most likely make the same decisions it just made and determine in step 2 that no action is necessary and the main loop simply exits without doing anything.


\subsection{Additional Infrastructures}
\subsubsection{Realtime Analytics Engine}
\subsubsection{Algorithm Switching Engine}
\subsubsection{Portfolio Algorithm Engine}

\section{Other Algorithmic Trading Usecases}


\section{ATS Infrastructure}
\subsection{Matching Engine}
\subsection{Client Tiering and other Rules}

